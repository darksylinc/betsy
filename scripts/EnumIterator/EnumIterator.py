#!/usr/bin/python2

import CppHeaderParser
import os

hHeader = \
"""// EnumIterator.py AUTOGENERATED FILE. ** DO NOT EDIT ** Run "python2 Run.py"
#pragma once

#include <vector>
#include <string>
#include "{1}"
"""

hBody = \
"""class {0}Enum
{{
public:
	struct EnumData
	{{
		{0}	enumValue;
		std::string			enumString;

		EnumData( {0}	_enumValue, const std::string &_enumString );
	}};

private:
	static EnumData mSortedByEnum[{1}+1];
	static EnumData mSortedByString[{1}+1];

	struct OrderByEnum;
	struct OrderByStr;

public:
	static const EnumData* begin()		{{ return &mSortedByEnum[0]; }}
	static const EnumData* end()		{{ return &mSortedByEnum[{1}]; }}

	/// Returns the min value reached by this enumerator
	static int minValue();

	/// Returns the max value reached by this enumerator
	static int maxValue();

	/// Returns the number of elements in the enum
	static size_t count();

	/// Returns true if integer value can be represented by the enum.
	/// O(1) if enum is contiguous, O(log N) otherwise
	static bool isValidValue( int value );

	/// Only available if the enum is contiguous. Otherwise it's a compiler error
	/// It's O(1)
	/// Returns empty string if value is not a valid enum value
	static const std::string& get( {0} value );

	/// Always available. O(1) if enum is contiguous, O(log N) otherwise
	/// Returns empty string if value is not a valid enum value
	static const std::string& find( {0} value );

	/// Will find the enumerator value based on its string representation.
	/// Returns false if the string doesn't match any value, leaving the output
	/// 'outValue' untouched (i.e. left uninitialized).
	static bool find( const std::string &strValue, {0} &outValue );

	/// Will find the enumerator value based on its string representation.
	/// Throws if the string doesn't match any value.
	static {0} find( const std::string &strValue );
}};
"""

hEnding = '\n'

cppHeader = \
"""// EnumIterator.py AUTOGENERATED FILE. ** DO NOT EDIT ** Run "python2 Run.py"

#include <algorithm>
#include <stdexcept>

const std::string BLANKSTRING = "";
"""

cppArrayDeclaration0 = \
"""{0}Enum::EnumData {0}Enum::mSortedByEnum[{1}+1] =
{{
"""

cppArrayDeclaration1 = \
"""}};

{0}Enum::EnumData {0}Enum::mSortedByString[{1}+1] =
{{"""


cppFunction = \
"""
//---------------------------------------------------------------------------------------
{0}Enum::EnumData::EnumData( {0} _enumValue,
										   const std::string &_enumString ) :
	enumValue( _enumValue ),
	enumString( _enumString )
{{
}}
//---------------------------------------------------------------------------------------
struct {0}Enum::OrderByEnum
{{
	bool operator () ( const {0}Enum::EnumData &_l, {0} _r ) const
	{{
		return _l.enumValue < _r;
	}}

	bool operator () ( {0} _l, const {0}Enum::EnumData &_r ) const
	{{
		return _l < _r.enumValue;
	}}

	bool operator () ( const {0}Enum::EnumData &_l, int _r ) const
	{{
		return _l.enumValue < _r;
	}}

	bool operator () ( int _l, const {0}Enum::EnumData &_r ) const
	{{
		return _l < _r.enumValue;
	}}
}};
//---------------------------------------------------------------------------------------
struct {0}Enum::OrderByStr
{{
	bool operator () ( const {0}Enum::EnumData &_l, const std::string &_r ) const
	{{
		return _l.enumString < _r;
	}}

	bool operator () ( const std::string &_l, const {0}Enum::EnumData &_r ) const
	{{
		return _l < _r.enumString;
	}}
}};
//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------
int {0}Enum::minValue()
{{
	return mSortedByEnum[0].enumValue;
}}
//---------------------------------------------------------------------------------------
int {0}Enum::maxValue()
{{
	return mSortedByEnum[{1}-1].enumValue;
}}
//---------------------------------------------------------------------------------------
size_t {0}Enum::count()
{{
	return {1};
}}
//---------------------------------------------------------------------------------------
bool {0}Enum::find( const std::string &strValue, {0} &outValue )
{{
	const EnumData* itor = std::lower_bound( &mSortedByString[0],
											 &mSortedByString[{1}],
											 strValue, OrderByStr() );

	if( itor != &mSortedByString[{1}] && itor->enumString == strValue )
	{{
		outValue = itor->enumValue;
		return true;
	}}
	else
	{{
		return false;
	}}
}}
//---------------------------------------------------------------------------------------
{0} {0}Enum::find( const std::string &strValue )
{{
	{0} retVal;
	const bool bFound = find( strValue, retVal );
	if( !bFound )
	{{
		throw std::invalid_argument( "String: " + strValue +
									 " is not a valid enum of type {0}" );
	}}

	return retVal;
}}
"""

cppFunctionContig = \
"""
//---------------------------------------------------------------------------------------
bool {0}Enum::isValidValue( int value )
{{
	return minValue() >= value && value <= maxValue();
}}
//---------------------------------------------------------------------------------------
const std::string& {0}Enum::get( {0} value )
{{
	const int idx = value - mSortedByEnum[0].enumValue;
	if( idx >= count() )
		return BLANKSTRING;

	return mSortedByEnum[idx].enumString;
}}
//---------------------------------------------------------------------------------------
const std::string& {0}Enum::find( {0} value )
{{
	return get( value );
}}
"""

cppFunctionNonContig = \
"""
//---------------------------------------------------------------------------------------
bool {0}Enum::isValidValue( int value )
{{
	const EnumData* itor = std::lower_bound( &mSortedByString[0],
											 &mSortedByString[{1}],
											 value, OrderByEnum() );

	if( itor != &mSortedByString[{1}] && itor->enumValue == value )
		return true;

	return false;
}}
//---------------------------------------------------------------------------------------
const std::string& {0}Enum::find( {0} value )
{{
	const EnumData *itor = std::lower_bound( begin(), end(), value, OrderByEnum() );

	if( itor != end() && itor->enumValue == value )
	{{
		return itor->enumString;
	}}
	else
	{{
		return BLANKSTRING;
	}}
}}
"""

def wasFileGeneratedByUs( fullPath ):
	firstLine = open( fullPath, "r" ).readline()
	return firstLine.find( '// EnumIterator.py AUTOGENERATED FILE. ** DO NOT EDIT ** Run "python2 Run.py"' ) != -1

def processEnumFileBegin():
	return cppHeader

def processEnumFile( fullPath, fileName ):
	try:
		cppParsed = CppHeaderParser.CppHeader( fullPath )
	except CppHeaderParser.CppParseError, e:
		print e
		sys.exit(1)

	outputCpp = '\n#include "{0}"\n\n#include "{1}Enum.h"\n\n'.format( fileName, os.path.splitext( fileName )[0] )
	outputHeader = hHeader.format( os.path.splitext( fileName )[0], fileName )

	for cppEnum in cppParsed.enums:
		# Grab all data from CppHeaderParser
		namespaces = cppEnum['namespace']
		if namespaces:
			namespaces = namespaces[0:-2].split( '::' )
		className = cppEnum['name']
		enumsByValue = {}
		enumsByString = {}
		for values in cppEnum['values']:
			enumsByValue[values['value']] = values['name']
			enumsByString[values['name']] = values['value']

		sortedByString = sorted( enumsByString.keys(), key=lambda x:x.lower() )

		# Sort enums by value and by string.
		enumKeys = enumsByValue.keys()
		prevKey = enumKeys[0]
		contiguous = True
		for i in range( 1, len( enumKeys ) ):
			if enumKeys[i] - prevKey != 1:
				contiguous = False
				break
			prevKey = enumKeys[i]

		# Generate .cpp file.
		outputStr = ''

		for namespace in namespaces: outputStr += 'namespace {0}\n{{\n'.format( namespace )

		outputStr += cppArrayDeclaration0.format( className, len( enumsByValue ) )

		for enumString in sortedByString:
			outputStr += '{0}Enum::EnumData( {1},		"{1}" ),//\n'.format( className, enumString )
		outputStr += '{0}Enum::EnumData( {1},		"__INVALID" )\n'.format( className, sortedByString[-1] )

		outputStr += cppArrayDeclaration1.format( className, len( enumsByValue ) )

		for enumString in sortedByString:
			outputStr += '{0}Enum::EnumData( {1},		"{1}" ),//\n'.format( className, enumString )
		outputStr += '{0}Enum::EnumData( {1},		"__INVALID" )\n'.format( className, sortedByString[-1] )

		outputStr += '};\n'

		outputStr += cppFunction.format( className, len( enumsByValue ) )

		if contiguous:
			outputStr += cppFunctionContig.format( className, len( enumsByValue ) )
		else:
			outputStr += cppFunctionNonContig.format( className, len( enumsByValue ) )

		for namespace in namespaces: outputStr += '}\n'

		# Generate .h file
		headerStr = ''
		for namespace in namespaces: headerStr += 'namespace {0}\n{{\n'.format( namespace )
		headerStr += hBody.format( className, len( enumsByValue ) )
		for namespace in namespaces: headerStr += '}\n'

		# Append to final output both .cpp and .h files
		outputHeader += headerStr
		outputCpp += outputStr

	outputHeader += hEnding

	return outputCpp, outputHeader
